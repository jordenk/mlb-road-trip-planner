// +build ignore

package main

import (
	"bytes"
	"fmt"
	"go/ast"
	"go/build"
	"go/format"
	"go/importer"
	"go/parser"
	"go/token"
	"go/types"
	"log"
	"os"
	"path/filepath"
	"strings"
	"time"
)

var (
	packagePath string
)

func init() {
	if pathEnv := os.Getenv("PACKAGE_PATH"); pathEnv != "" {
		packagePath = pathEnv
	} else {
		packagePath = "../../../../../"
	}
}

func main() {
	log.SetFlags(0)

	log.Println("Generating API registry into api_registry.gen.go")
	log.Println(strings.Repeat("-", 80))

	buildPkg, err := build.Import(
		"github.com/elastic/go-elasticsearch/esapi",
		packagePath,
		build.ImportComment)
	if err != nil {
		log.Fatalf("ERROR: %s", err)
	}

	log.Printf("Pkg: %s\nDir: %s\n\n", buildPkg.Name, buildPkg.Dir)

	fset := token.NewFileSet()
	files := make([]*ast.File, len(buildPkg.GoFiles))

	for i, fname := range buildPkg.GoFiles {
		fpath := filepath.Join(buildPkg.Dir, fname)
		f, err := parser.ParseFile(fset, fpath, nil, parser.DeclarationErrors|parser.ParseComments)
		if err != nil {
			log.Fatalf("ERROR: %s", err)
		}
		files[i] = f
	}

	cfg := types.Config{IgnoreFuncBodies: true, Importer: importer.Default()}
	inf := types.Info{Defs: make(map[*ast.Ident]types.Object)}
	_, err = cfg.Check(buildPkg.ImportPath, fset, files, &inf)
	if err != nil {
		log.Fatalf("ERROR: %s", err)
	}

	var s = time.Now()
	var b bytes.Buffer
	var n int

	b.WriteString("// Code generated by go generate: DO NOT EDIT\n\n")
	b.WriteString("package gentests\n\n")
	b.WriteString("func init() {\n")
	b.WriteString("apiRegistry = map[string]map[string]string{\n\n")

	for i, f := range files {
		for _, decl := range f.Decls {
			genDecl, ok := decl.(*ast.GenDecl)
			if !ok || genDecl.Tok != token.TYPE {
				continue
			}
			for _, spec := range genDecl.Specs {
				typeSpec, ok := spec.(*ast.TypeSpec)
				if !ok {
					continue
				}
				obj := inf.Defs[typeSpec.Name]
				if obj == nil || !obj.Exported() {
					continue
				}
				if !strings.HasSuffix(obj.Name(), "Request") {
					continue
				}

				namedObj := obj.(*types.TypeName).Type().(*types.Named)
				structObj, ok := namedObj.Underlying().(*types.Struct)
				if !ok {
					continue
				}

				log.Printf("%-3d | %s{}\n", i, obj.Name())
				b.WriteString(fmt.Sprintf("%q: map[string]string{\n", obj.Name()))

				for j := 0; j < structObj.NumFields(); j++ {
					field := structObj.Field(j)
					log.Printf("        %s %s", field.Name(), field.Type())
					b.WriteString(fmt.Sprintf("%q: %q,\n", field.Name(), field.Type()))
				}
				log.Printf("\n")
				b.WriteString("},\n\n")
			}
		}
		n++
	}

	b.WriteString("}\n")
	b.WriteString("}\n")

	out, err := format.Source(b.Bytes())
	if err != nil {
		log.Fatalf("ERROR: %s", err)
	}

	outFile, err := os.Create("api_registry.gen.go")
	if err != nil {
		log.Fatalf("ERROR: %s", err)
	}

	_, err = outFile.Write(out)
	if err != nil {
		log.Fatalf("ERROR: %s", err)
	}

	log.Printf("Processed %d files in %s.\n", n, time.Since(s).Truncate(time.Millisecond))
}
